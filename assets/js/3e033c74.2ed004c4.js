"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[1651],{8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var s=r(6540);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}},8922:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"physical-ai-book/chapter4/isaac-gym-rl","title":"4.2 Isaac Gym for Reinforcement Learning","description":"Learning Objectives","source":"@site/docs/physical-ai-book/chapter4/isaac-gym-rl.md","sourceDirName":"physical-ai-book/chapter4","slug":"/physical-ai-book/chapter4/isaac-gym-rl","permalink":"/docs/physical-ai-book/chapter4/isaac-gym-rl","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammad-anas35/RAGai/tree/main/docs/physical-ai-book/chapter4/isaac-gym-rl.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4: The AI-Robot Brain: The NVIDIA Isaac Platform","permalink":"/docs/physical-ai-book/chapter4/"},"next":{"title":"4.4 Isaac ROS 2 Bridge","permalink":"/docs/physical-ai-book/chapter4/isaac-ros2-bridge"}}');var i=r(4848),t=r(8453);const a={},o="4.2 Isaac Gym for Reinforcement Learning",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Tensor API Example",id:"tensor-api-example",level:2},{value:"Humanoid Locomotion Example",id:"humanoid-locomotion-example",level:2},{value:"Training with PPO",id:"training-with-ppo",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"42-isaac-gym-for-reinforcement-learning",children:"4.2 Isaac Gym for Reinforcement Learning"})}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Understand Isaac Gym's tensor-based API for RL"}),"\n",(0,i.jsx)(n.li,{children:"Create parallel training environments"}),"\n",(0,i.jsx)(n.li,{children:"Train humanoid locomotion policies"}),"\n",(0,i.jsx)(n.li,{children:"Use GPU-accelerated RL algorithms"}),"\n",(0,i.jsx)(n.li,{children:"Integrate with popular RL frameworks (Stable Baselines3, RLlib)"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Isaac Gym"})," is NVIDIA's physics simulation environment optimized for reinforcement learning. Unlike traditional simulators, Isaac Gym provides ",(0,i.jsx)(n.strong,{children:"direct GPU tensor access"})," to physics states, enabling:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Training on ",(0,i.jsx)(n.strong,{children:"thousands of parallel environments"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"10-100x faster"})," than CPU-based RL"]}),"\n",(0,i.jsx)(n.li,{children:"Seamless integration with PyTorch/JAX"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Feature"}),(0,i.jsx)(n.th,{children:"Traditional RL"}),(0,i.jsx)(n.th,{children:"Isaac Gym"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Environments"})}),(0,i.jsx)(n.td,{children:"8-16 (CPU)"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:"4096+"})," (GPU)"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Physics"})}),(0,i.jsx)(n.td,{children:"CPU"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"GPU (PhysX)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Data Transfer"})}),(0,i.jsx)(n.td,{children:"CPU \u2194 GPU"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"GPU-only"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Training Speed"})}),(0,i.jsx)(n.td,{children:"1x"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"10-100x"})})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"tensor-api-example",children:"Tensor API Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from isaacgym import gymapi\r\nimport torch\r\n\r\n# Create gym\r\ngym = gymapi.acquire_gym()\r\n\r\n# Create 1024 parallel environments\r\nnum_envs = 1024\r\nenvs = []\r\nfor i in range(num_envs):\r\n    env = gym.create_env(sim, env_lower, env_upper, num_per_row)\r\n    envs.append(env)\r\n\r\n# Get states as GPU tensors (no CPU transfer!)\r\nroot_states = gym.acquire_actor_root_state_tensor(sim)\r\ndof_states = gym.acquire_dof_state_tensor(sim)\r\n\r\n# PyTorch tensors on GPU\r\nroot_tensor = gymtorch.wrap_tensor(root_states)\r\ndof_tensor = gymtorch.wrap_tensor(dof_states)\r\n\r\n# Apply actions (all envs simultaneously)\r\ngym.set_dof_position_target_tensor(sim, actions_tensor)\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"humanoid-locomotion-example",children:"Humanoid Locomotion Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class HumanoidEnv:\r\n    def __init__(self, num_envs=1024):\r\n        self.num_envs = num_envs\r\n        self.device = "cuda:0"\r\n        \r\n    def reset(self):\r\n        # Reset all envs in parallel\r\n        return self.obs_buf.clone()\r\n    \r\n    def step(self, actions):\r\n        # Apply actions to all robots\r\n        self.gym.set_dof_position_target_tensor(\r\n            self.sim, \r\n            gymtorch.unwrap_tensor(actions)\r\n        )\r\n        \r\n        # Step physics (GPU)\r\n        self.gym.simulate(self.sim)\r\n        self.gym.fetch_results(self.sim, True)\r\n        \r\n        # Compute rewards (GPU)\r\n        rewards = self.compute_rewards()\r\n        \r\n        return self.obs_buf, rewards, self.reset_buf, {}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"training-with-ppo",children:"Training with PPO"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from stable_baselines3 import PPO\r\n\r\nenv = HumanoidEnv(num_envs=2048)\r\n\r\nmodel = PPO(\r\n    "MlpPolicy",\r\n    env,\r\n    n_steps=16,\r\n    batch_size=32768,\r\n    device="cuda"\r\n)\r\n\r\nmodel.learn(total_timesteps=10_000_000)\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Training Time"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"CPU (16 envs): ~48 hours"}),"\n",(0,i.jsxs)(n.li,{children:["Isaac Gym (2048 envs): ",(0,i.jsx)(n.strong,{children:"~2 hours"})," \u26a1"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Tensor API"})," eliminates CPU-GPU transfers",(0,i.jsx)(n.br,{}),"\n","\u2705 ",(0,i.jsx)(n.strong,{children:"Massively parallel"})," (1000+ environments)",(0,i.jsx)(n.br,{}),"\n","\u2705 ",(0,i.jsx)(n.strong,{children:"10-100x faster"})," RL training",(0,i.jsx)(n.br,{}),"\n","\u2705 ",(0,i.jsx)(n.strong,{children:"PyTorch integration"})," for easy RL workflows"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Previous Section"}),": ",(0,i.jsx)(n.a,{href:"/docs/physical-ai-book/chapter4/isaac-sim-architecture",children:"\u2190 4.1 Isaac Sim Architecture"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Next Section"}),": ",(0,i.jsx)(n.a,{href:"/docs/physical-ai-book/chapter4/synthetic-data",children:"4.3 Synthetic Data Generation \u2192"})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);