"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[9255],{318:(n,o,r)=>{r.r(o),r.d(o,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>e,toc:()=>c});const e=JSON.parse('{"id":"physical-ai-book/chapter5/whole-body-control","title":"5.3 Whole-Body Control","description":"Learning Objectives","source":"@site/docs/physical-ai-book/chapter5/whole-body-control.md","sourceDirName":"physical-ai-book/chapter5","slug":"/physical-ai-book/chapter5/whole-body-control","permalink":"/docs/physical-ai-book/chapter5/whole-body-control","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammad-anas35/RAGai/tree/main/docs/physical-ai-book/chapter5/whole-body-control.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"5.4 Real Robot Deployment","permalink":"/docs/physical-ai-book/chapter5/real-robot-deployment"},"next":{"title":"6.3 Deployment Strategies","permalink":"/docs/physical-ai-book/chapter6/deployment-strategies"}}');var t=r(4848),i=r(8453);const a={},s="5.3 Whole-Body Control",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Hierarchical Task Control",id:"hierarchical-task-control",level:2},{value:"Quadratic Programming (QP)",id:"quadratic-programming-qp",level:2},{value:"Locomotion + Manipulation",id:"locomotion--manipulation",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(n){const o={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.header,{children:(0,t.jsx)(o.h1,{id:"53-whole-body-control",children:"5.3 Whole-Body Control"})}),"\n",(0,t.jsx)(o.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"Understand hierarchical control for humanoids"}),"\n",(0,t.jsx)(o.li,{children:"Implement task-space control"}),"\n",(0,t.jsx)(o.li,{children:"Coordinate locomotion and manipulation"}),"\n",(0,t.jsx)(o.li,{children:"Use quadratic programming for whole-body optimization"}),"\n"]}),"\n",(0,t.jsx)(o.hr,{}),"\n",(0,t.jsx)(o.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(o.p,{children:[(0,t.jsx)(o.strong,{children:"Whole-body control"})," coordinates all joints to achieve multiple simultaneous tasks:"]}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"Walk while carrying an object"}),"\n",(0,t.jsx)(o.li,{children:"Maintain balance while reaching"}),"\n",(0,t.jsx)(o.li,{children:"Avoid obstacles with arms and legs"}),"\n"]}),"\n",(0,t.jsx)(o.hr,{}),"\n",(0,t.jsx)(o.h2,{id:"hierarchical-task-control",children:"Hierarchical Task Control"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-python",children:'# Task hierarchy (priority order)\r\ntasks = [\r\n    ("balance", priority=1),      # Highest priority\r\n    ("walk_forward", priority=2),\r\n    ("reach_target", priority=3),\r\n    ("look_at_object", priority=4)  # Lowest priority\r\n]\r\n\r\n# Solve with null-space projection\r\ndef solve_hierarchical_control(tasks):\r\n    q_dot = np.zeros(n_dof)\r\n    P = np.eye(n_dof)  # Null-space projector\r\n    \r\n    for task_name, priority in tasks:\r\n        J = task_jacobian(task_name)\r\n        x_dot_des = task_velocity(task_name)\r\n        \r\n        # Project into null-space of higher-priority tasks\r\n        J_proj = J @ P\r\n        \r\n        # Solve for this task\r\n        q_dot_task = np.linalg.pinv(J_proj) @ (x_dot_des - J @ q_dot)\r\n        q_dot += q_dot_task\r\n        \r\n        # Update null-space projector\r\n        P = P @ (np.eye(n_dof) - np.linalg.pinv(J_proj) @ J_proj)\r\n    \r\n    return q_dot\n'})}),"\n",(0,t.jsx)(o.hr,{}),"\n",(0,t.jsx)(o.h2,{id:"quadratic-programming-qp",children:"Quadratic Programming (QP)"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-python",children:"import cvxpy as cp\r\n\r\n# Decision variables\r\nq_ddot = cp.Variable(n_dof)  # Joint accelerations\r\ncontact_forces = cp.Variable(n_contacts * 3)\r\n\r\n# Objective: minimize control effort\r\ncost = cp.sum_squares(q_ddot)\r\n\r\n# Constraints\r\nconstraints = [\r\n    # Dynamics: M*q_ddot + C = tau + J^T*f\r\n    M @ q_ddot + C == tau + J.T @ contact_forces,\r\n    \r\n    # Friction cone\r\n    friction_cone(contact_forces),\r\n    \r\n    # Joint limits\r\n    q_ddot_min <= q_ddot, q_ddot <= q_ddot_max,\r\n]\r\n\r\n# Solve\r\nprob = cp.Problem(cp.Minimize(cost), constraints)\r\nprob.solve()\n"})}),"\n",(0,t.jsx)(o.hr,{}),"\n",(0,t.jsx)(o.h2,{id:"locomotion--manipulation",children:"Locomotion + Manipulation"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-python",children:"class WholeBodyController:\r\n    def compute_control(self, state, targets):\r\n        # Task 1: Maintain CoM over support polygon\r\n        com_task = self.com_controller(state.com, targets.com)\r\n        \r\n        # Task 2: Swing foot trajectory\r\n        swing_task = self.swing_controller(state.swing_foot, targets.swing_foot)\r\n        \r\n        # Task 3: Reach with hand\r\n        reach_task = self.reach_controller(state.hand_pos, targets.hand_pos)\r\n        \r\n        # Solve QP with all tasks\r\n        return self.qp_solver([com_task, swing_task, reach_task])\n"})}),"\n",(0,t.jsx)(o.hr,{}),"\n",(0,t.jsx)(o.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(o.p,{children:["\u2705 ",(0,t.jsx)(o.strong,{children:"Hierarchical control"})," prioritizes tasks (balance > locomotion > manipulation)",(0,t.jsx)(o.br,{}),"\n","\u2705 ",(0,t.jsx)(o.strong,{children:"Null-space projection"})," satisfies lower-priority tasks without affecting higher ones",(0,t.jsx)(o.br,{}),"\n","\u2705 ",(0,t.jsx)(o.strong,{children:"QP"})," optimizes control while respecting constraints",(0,t.jsx)(o.br,{}),"\n","\u2705 ",(0,t.jsx)(o.strong,{children:"Whole-body"})," enables complex behaviors (walk + reach + look)"]}),"\n",(0,t.jsx)(o.hr,{}),"\n",(0,t.jsxs)(o.p,{children:[(0,t.jsx)(o.strong,{children:"Previous Section"}),": ",(0,t.jsx)(o.a,{href:"/docs/physical-ai-book/chapter5/manipulation-grasping",children:"\u2190 5.2 Manipulation and Grasping"}),(0,t.jsx)(o.br,{}),"\n",(0,t.jsx)(o.strong,{children:"Next Section"}),": ",(0,t.jsx)(o.a,{href:"/docs/physical-ai-book/chapter5/real-robot-deployment",children:"5.4 Real Robot Deployment \u2192"})]})]})}function h(n={}){const{wrapper:o}={...(0,i.R)(),...n.components};return o?(0,t.jsx)(o,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,o,r)=>{r.d(o,{R:()=>a,x:()=>s});var e=r(6540);const t={},i=e.createContext(t);function a(n){const o=e.useContext(i);return e.useMemo(function(){return"function"==typeof n?n(o):{...o,...n}},[o,n])}function s(n){let o;return o=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),e.createElement(i.Provider,{value:o},n.children)}}}]);