"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[6179],{7975:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"physical-ai-book/chapter5/manipulation-grasping","title":"5.2 Manipulation and Grasping","description":"Learning Objectives","source":"@site/docs/physical-ai-book/chapter5/manipulation-grasping.md","sourceDirName":"physical-ai-book/chapter5","slug":"/physical-ai-book/chapter5/manipulation-grasping","permalink":"/RAGai/docs/physical-ai-book/chapter5/manipulation-grasping","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammad-anas35/RAGai/tree/main/docs/physical-ai-book/chapter5/manipulation-grasping.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"5.1 Locomotion Control","permalink":"/RAGai/docs/physical-ai-book/chapter5/locomotion-control"},"next":{"title":"5.4 Real Robot Deployment","permalink":"/RAGai/docs/physical-ai-book/chapter5/real-robot-deployment"}}');var s=r(4848),o=r(8453);const t={},a="5.2 Manipulation and Grasping",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Inverse Kinematics (IK)",id:"inverse-kinematics-ik",level:2},{value:"Grasp Planning",id:"grasp-planning",level:2},{value:"Force Control",id:"force-control",level:2},{value:"RL for Dexterous Manipulation",id:"rl-for-dexterous-manipulation",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function p(n){const e={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"52-manipulation-and-grasping",children:"5.2 Manipulation and Grasping"})}),"\n",(0,s.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Understand inverse kinematics for manipulation"}),"\n",(0,s.jsx)(e.li,{children:"Implement grasp planning algorithms"}),"\n",(0,s.jsx)(e.li,{children:"Use force/torque feedback for stable grasps"}),"\n",(0,s.jsx)(e.li,{children:"Train RL policies for dexterous manipulation"}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Manipulation"})," is the ability to interact with objects. For humanoid robots, this involves:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Reaching"}),": Moving the arm to a target pose"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Grasping"}),": Securely holding objects"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Manipulation"}),": Moving grasped objects"]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"inverse-kinematics-ik",children:"Inverse Kinematics (IK)"}),"\n",(0,s.jsx)(e.p,{children:"IK computes joint angles to achieve a desired end-effector pose:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'from scipy.optimize import minimize\r\n\r\ndef inverse_kinematics(target_pos, target_orient, initial_guess):\r\n    """\r\n    Solve IK using numerical optimization\r\n    """\r\n    def cost_function(joint_angles):\r\n        # Forward kinematics\r\n        ee_pos, ee_orient = forward_kinematics(joint_angles)\r\n        \r\n        # Position error\r\n        pos_error = np.linalg.norm(ee_pos - target_pos)\r\n        \r\n        # Orientation error\r\n        orient_error = orientation_distance(ee_orient, target_orient)\r\n        \r\n        return pos_error + orient_error\r\n    \r\n    result = minimize(cost_function, initial_guess, method=\'SLSQP\')\r\n    return result.x\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"grasp-planning",children:"Grasp Planning"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Parallel jaw gripper\r\ndef compute_grasp_pose(object_mesh):\r\n    # Find antipodal grasp points\r\n    points = sample_surface_points(object_mesh, n=1000)\r\n    \r\n    best_grasp = None\r\n    best_score = -np.inf\r\n    \r\n    for p1 in points:\r\n        for p2 in points:\r\n            if is_antipodal(p1, p2, object_mesh):\r\n                score = grasp_quality(p1, p2, object_mesh)\r\n                if score > best_score:\r\n                    best_score = score\r\n                    best_grasp = (p1, p2)\r\n    \r\n    return best_grasp\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"force-control",children:"Force Control"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"class ForceController(Node):\r\n    def __init__(self):\r\n        super().__init__('force_controller')\r\n        self.ft_sub = self.create_subscription(\r\n            WrenchStamped, '/ft_sensor', self.ft_callback, 10\r\n        )\r\n        self.target_force = 5.0  # Newtons\r\n        \r\n    def ft_callback(self, msg):\r\n        current_force = msg.wrench.force.z\r\n        \r\n        # PI controller\r\n        error = self.target_force - current_force\r\n        control = self.kp * error + self.ki * self.integral\r\n        \r\n        # Adjust gripper position\r\n        self.gripper_pub.publish(Float64(data=control))\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"rl-for-dexterous-manipulation",children:"RL for Dexterous Manipulation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"class ManipulationEnv:\r\n    def compute_reward(self):\r\n        # Object-to-goal distance\r\n        dist_reward = -torch.norm(self.object_pos - self.goal_pos, dim=-1)\r\n        \r\n        # Grasp stability\r\n        grasp_reward = self.is_grasped.float() * 10.0\r\n        \r\n        # Success bonus\r\n        success_reward = self.success.float() * 100.0\r\n        \r\n        return dist_reward + grasp_reward + success_reward\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(e.p,{children:["\u2705 ",(0,s.jsx)(e.strong,{children:"IK"})," computes joint angles for desired end-effector poses",(0,s.jsx)(e.br,{}),"\n","\u2705 ",(0,s.jsx)(e.strong,{children:"Grasp planning"})," finds stable contact points",(0,s.jsx)(e.br,{}),"\n","\u2705 ",(0,s.jsx)(e.strong,{children:"Force control"})," maintains desired contact forces",(0,s.jsx)(e.br,{}),"\n","\u2705 ",(0,s.jsx)(e.strong,{children:"RL"})," learns dexterous manipulation policies"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Previous Section"}),": ",(0,s.jsx)(e.a,{href:"/RAGai/docs/physical-ai-book/chapter5/locomotion-control",children:"\u2190 5.1 Locomotion Control"}),(0,s.jsx)(e.br,{}),"\n",(0,s.jsx)(e.strong,{children:"Next Section"}),": ",(0,s.jsx)(e.a,{href:"/RAGai/docs/physical-ai-book/chapter5/whole-body-control",children:"5.3 Whole-Body Control \u2192"})]})]})}function d(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(p,{...n})}):p(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>t,x:()=>a});var i=r(6540);const s={},o=i.createContext(s);function t(n){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:t(n.components),i.createElement(o.Provider,{value:e},n.children)}}}]);