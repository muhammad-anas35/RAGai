"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[426],{8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var o=r(6540);const t={},i=o.createContext(t);function s(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(i.Provider,{value:n},e.children)}},9424:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"physical-ai-book/chapter5/real-robot-deployment","title":"5.4 Real Robot Deployment","description":"Learning Objectives","source":"@site/docs/physical-ai-book/chapter5/real-robot-deployment.md","sourceDirName":"physical-ai-book/chapter5","slug":"/physical-ai-book/chapter5/real-robot-deployment","permalink":"/docs/physical-ai-book/chapter5/real-robot-deployment","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammad-anas35/RAGai/tree/main/docs/physical-ai-book/chapter5/real-robot-deployment.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"5.2 Manipulation and Grasping","permalink":"/docs/physical-ai-book/chapter5/manipulation-grasping"},"next":{"title":"5.3 Whole-Body Control","permalink":"/docs/physical-ai-book/chapter5/whole-body-control"}}');var t=r(4848),i=r(8453);const s={},a="5.4 Real Robot Deployment",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Sim-to-Real Gap",id:"sim-to-real-gap",level:2},{value:"Safety Mechanisms",id:"safety-mechanisms",level:2},{value:"Deployment Workflow",id:"deployment-workflow",level:2},{value:"Domain Randomization",id:"domain-randomization",level:2},{value:"Monitoring and Debugging",id:"monitoring-and-debugging",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"54-real-robot-deployment",children:"5.4 Real Robot Deployment"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand sim-to-real transfer challenges"}),"\n",(0,t.jsx)(n.li,{children:"Implement safety mechanisms for real robots"}),"\n",(0,t.jsx)(n.li,{children:"Deploy trained policies on hardware"}),"\n",(0,t.jsx)(n.li,{children:"Monitor and debug real-world performance"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"Deploying algorithms from simulation to real robots requires:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Safety"}),": Emergency stops, joint limits, collision avoidance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Robustness"}),": Handle sensor noise, delays, model mismatch"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitoring"}),": Real-time diagnostics and logging"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"sim-to-real-gap",children:"Sim-to-Real Gap"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Challenge"}),(0,t.jsx)(n.th,{children:"Solution"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Model mismatch"})}),(0,t.jsx)(n.td,{children:"System identification, adaptive control"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Sensor noise"})}),(0,t.jsx)(n.td,{children:"Kalman filtering, sensor fusion"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Delays"})}),(0,t.jsx)(n.td,{children:"Predictive control, buffering"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Unmodeled dynamics"})}),(0,t.jsx)(n.td,{children:"Domain randomization in sim"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"safety-mechanisms",children:"Safety Mechanisms"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class SafetyMonitor(Node):\r\n    def __init__(self):\r\n        super().__init__(\'safety_monitor\')\r\n        self.emergency_stop = False\r\n        \r\n    def check_safety(self, state):\r\n        # Joint limit check\r\n        if np.any(state.joint_pos < self.joint_min) or \\\r\n           np.any(state.joint_pos > self.joint_max):\r\n            self.trigger_emergency_stop("Joint limit violated")\r\n        \r\n        # Velocity limit check\r\n        if np.any(np.abs(state.joint_vel) > self.vel_max):\r\n            self.trigger_emergency_stop("Velocity too high")\r\n        \r\n        # Torque limit check\r\n        if np.any(np.abs(state.joint_torque) > self.torque_max):\r\n            self.trigger_emergency_stop("Torque too high")\r\n        \r\n        # Tilt check (IMU)\r\n        if state.imu_tilt > 30.0:  # degrees\r\n            self.trigger_emergency_stop("Robot tilting")\r\n    \r\n    def trigger_emergency_stop(self, reason):\r\n        self.get_logger().error(f"EMERGENCY STOP: {reason}")\r\n        self.emergency_stop = True\r\n        # Send zero torques to all joints\r\n        self.send_zero_torques()\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"deployment-workflow",children:"Deployment Workflow"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# 1. Load trained policy\r\npolicy = torch.load("trained_policy.pth")\r\npolicy.eval()\r\n\r\n# 2. Initialize robot interface\r\nrobot = RobotInterface()\r\nrobot.enable_motors()\r\n\r\n# 3. Main control loop\r\nrate = robot.create_rate(100)  # 100 Hz\r\nwhile not rospy.is_shutdown():\r\n    # Get state\r\n    state = robot.get_state()\r\n    \r\n    # Safety check\r\n    if not safety_monitor.check_safety(state):\r\n        break\r\n    \r\n    # Compute action\r\n    with torch.no_grad():\r\n        obs = preprocess_state(state)\r\n        action = policy(obs)\r\n    \r\n    # Apply action\r\n    robot.set_joint_commands(action)\r\n    \r\n    # Log data\r\n    logger.log(state, action)\r\n    \r\n    rate.sleep()\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"domain-randomization",children:"Domain Randomization"}),"\n",(0,t.jsx)(n.p,{children:"Train policies robust to real-world variations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# In simulation\r\nclass RandomizedEnv:\r\n    def reset(self):\r\n        # Randomize physics\r\n        self.mass = np.random.uniform(0.8, 1.2) * self.nominal_mass\r\n        self.friction = np.random.uniform(0.5, 1.5)\r\n        \r\n        # Randomize sensors\r\n        self.imu_noise = np.random.uniform(0.01, 0.05)\r\n        self.joint_noise = np.random.uniform(0.001, 0.01)\r\n        \r\n        # Randomize delays\r\n        self.control_delay = np.random.uniform(0.0, 0.02)  # 0-20ms\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"monitoring-and-debugging",children:"Monitoring and Debugging"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class PerformanceMonitor(Node):\r\n    def __init__(self):\r\n        super().__init__('performance_monitor')\r\n        self.metrics = {\r\n            'control_freq': [],\r\n            'tracking_error': [],\r\n            'power_consumption': [],\r\n        }\r\n    \r\n    def log_metrics(self, state, command):\r\n        # Control frequency\r\n        self.metrics['control_freq'].append(1.0 / dt)\r\n        \r\n        # Tracking error\r\n        error = np.linalg.norm(state.joint_pos - command.joint_pos)\r\n        self.metrics['tracking_error'].append(error)\r\n        \r\n        # Power\r\n        power = np.sum(state.joint_torque * state.joint_vel)\r\n        self.metrics['power_consumption'].append(power)\r\n    \r\n    def publish_diagnostics(self):\r\n        msg = DiagnosticArray()\r\n        msg.status.append(DiagnosticStatus(\r\n            name=\"Control Frequency\",\r\n            message=f\"{np.mean(self.metrics['control_freq']):.1f} Hz\"\r\n        ))\r\n        self.diagnostics_pub.publish(msg)\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(n.p,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Safety first"}),": Implement emergency stops and limit checks",(0,t.jsx)(n.br,{}),"\n","\u2705 ",(0,t.jsx)(n.strong,{children:"Domain randomization"})," bridges sim-to-real gap",(0,t.jsx)(n.br,{}),"\n","\u2705 ",(0,t.jsx)(n.strong,{children:"Monitoring"})," enables real-time diagnostics",(0,t.jsx)(n.br,{}),"\n","\u2705 ",(0,t.jsx)(n.strong,{children:"Gradual deployment"}),": Test in safe environments first"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Previous Section"}),": ",(0,t.jsx)(n.a,{href:"/docs/physical-ai-book/chapter5/whole-body-control",children:"\u2190 5.3 Whole-Body Control"}),(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Next Chapter"}),": ",(0,t.jsx)(n.a,{href:"/docs/physical-ai-book/chapter6/",children:"Chapter 6: Conversational Robotics \u2192"})]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);